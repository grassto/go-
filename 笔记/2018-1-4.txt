1.起源与发展
	是谷歌公司程序员从2009.9.21开始，用20%的空余时间来参与Go语言的研发工作。
	
	主要开发者有三个人：Griesemer、Thompson和Pike
	这是一个由计算机领域 “发明之父” 所组成的黄金团队，他们对系统编程语言，操作系统和并行都有着非常深刻的见解
	
	时间轴：

    2007 年 9 月 21 日：雏形设计
    2009 年 11 月 10日：首次公开发布
    2010 年 1 月 8 日：当选 2009 年年度语言
    2010 年 5 月：谷歌投入使用
    2011 年 5 月 5 日：Google App Engine 支持 Go 语言

	
2.为什么要创造Go
    编译快、运行速度快、易于开发
	
	
3.Go语言的发展目标
	主要目标：将静态语言的安全性和高效性与动态语言的易开发性进行结合
	
	Go是类型安全并且内存安全的编程语言。
	
	目标二：对网络通信、并发和并行编程的支持 （goroutine轻量级线程，channel实现goroutine之间的通信）
	这也是go语言的最大的竞争力
	
	
4.Go不需要开发者自行处理内存问题
	go像其他静态语言一样执行本地代码，但它依旧是运行在某种意义上的虚拟机，以此来实现快速高效的垃圾回收。

	
5.Go还能够在运行时进行反射相关的操作。


6.使用 go install 能够很轻松地对第三方包进行部署。
	还能够使用C编写的库文件。
	
	
7.Go的语言特性
	1）Go没有类和继承的概念，它通过接口（interface）来实现多态。
	
	2）Go不允许强制类型转换，让所有的东西都是显式的。
	
	3）支持交叉编译（如：可以在Linux的机器上开发windows应用程序）。
	
	4）Go语言完全支持UTF-8编码，真正的国际化。
	
	
8.Go的用途
	1）主要用来搭建高性能、支持多并发的服务器程序。大型分布式应用程序
	
	2）也可以用于实现一般的目标，如：文本处理，前端展现。
	
	3）因为垃圾回收和自动内存分配的原因，Go不适合用来开发对实时性要求很高的软件。
	
	4）Go语言可以在Android系统下运行。
	
	
9.Go的特性缺失
	不支持函数重载和操作符重载
	为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换
	Go 语言通过另一种途径实现面向对象设计来放弃类和类型的继承
	尽管在接口的使用方面可以实现类似变体类型的功能，但本身不支持变体类型
	不支持动态加载代码
	不支持动态链接库
	不支持泛型
	通过 recover 和 panic 来替代异常机制
	不支持断言
	不支持静态变量
	
	
10.The Way to Go的总结
	1）简化问题，易于学习
	2）内存管理，简洁语法，易于使用
	3）快速编译，高效开发
	4）高效执行
	5）并发支持，轻松驾驭
	6）静态类型
	7）标准类库，规范统一
	8）易于部署
	9）文档全面
	10）免费开源
	
	
11.GOPATH的目录结构被分为三个文件夹
	src：存放源码文件
	pkg：包文件
	bin：可执行文件
	
	
12.几个重要的环境变量：
    $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go（Linux系统），当然，你也可以安装在别的地方。
    $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。
    $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。
    $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

	
13.Go运行时（runtime）
	代码在src的runtime下，主要负责包括内存管理、垃圾回收、栈处理、goroutine、channel、切片（slice）、map和反射（reflection）等。
	Go的可执行文件比源代码文件要大的多（Go的runtime嵌入到了每一个可执行文件中）

	
14.Go的部署
	部署不需要依赖其他任何文件，只需要一个单独的静态文件。
	
	
15.格式化代码（gofmt）
	命令行输入gofmt -w test.go会格式化该源文件的代码，然后覆盖原代码
	gofmt map1 会格式化并重写map1目录及其子目录下的所有go源文件
	
	gofmt 也可以通过在参数 -r 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：<原始内容> -> <替换内容>。
	实例：
	gofmt -r '(a) -> a' –w *.go
	上面的代码会将源文件中没有意义的括号去掉。

	gofmt -r 'a[n:len(a)] -> a[n:]' –w *.go
	上面的代码会将源文件中多余的 len(a) 去掉。

	gofmt –r 'A.Func1(a,b) -> A.Func2(b,a)' –w *.go
	上面的代码会将源文件中符合条件的函数的参数调换位置。
	
	
16.生成代码文档（go doc）
	会从Go程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成文档。
	一般用法：godoc package 获取包的文档注释
			  godoc package/subpackage 获取子包的文档注释
			  godoc package function 获取某个函数在某个包中的文档注释
	这个工具只能获取Go安装目录src下的注释内容。
	
	godoc -http=:6060，然后使用浏览器打开 http://localhost:6060 后，你就可以看到本地文档浏览服务器提供的页面。
	相关文档
	https://godoc.org/golang.org/x/tools/cmd/godoc
	
	
17.其他工具
	go install 安装Go包的工具
	go fix  主要负责简单的、重复的、枯燥无味的修改工作，如果复杂，会给出文件名和代码行数提示，以便快速定位。
	go test 单元测试
	
	
18.go与其他语言进行交互（如：C，C++）
	需要时再看
	
	
19.导入包
	如果包名不是以 . 或 / 开头，如 "fmt" 或者 "container/list"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。
	若在前面加下划线_，则表示只引用该包中的init函数，即只为调用该包中的init函数
	
	
20.所有的包名都应该使用小写字母
   每个go程序都应该包含一个名为main的包
   如果要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。
   一个目录下只能有一个包
   
   
21.可见性规则
	当标识符（常量、变量、类型、函数名、结构字段等）以一个大写字母开头，则可被其他包引用，若为小写，则不行。很像public和private
	
	
22.包的别名
	import (
		fm "fmt"
		pkg4 "package4"
	)
	fm.Println("aaa")
	
	
23.包中的函数
	程序必须有main函数，此为程序的入口，若有init()函数，则会先执行此函数
	使用其他包的函数，必须用包名（别名）.函数名来调用函数
	
	
24.程序正常退出的代码为0，即Program exited with code 0;如果程序因为异常而终止，则返回非0值，如：1。


25.因式分解法：
	type (
	   IZ int
	   FZ float64
	   STR string
	)
	
	
26.Go程序的一般结构
	1）import之后，开始对常量、变量和类型的定义或声明。
	2）执行init函数（若存在）
	3）执行main函数（若当前是main包）
	
	
27.程序执行顺序
	
    1）按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
    2）如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
    3）然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。
    4）在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

	
28.类型转换
	valueOfTypeB = typeB(valueOfTypeA)
	例：a := 5.0
		b := int(a)
		
		
29.常量const
	1）存储在常量中的数据类型只能是布尔值、数字型（整数型、浮点型和复数）和字符类型 
	const identifier [type] = value
	例：const Pi = 3.1415926
	
	2）支持反斜杠换行
	const i = 3.23424\
				434
	3）并行赋值		
	const beef, two, c = "eat", 2, "veg"
	const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
	const (
		Monday, Tuesday, Wednesday = 1, 2, 3
		Thursday, Friday, Saturday = 4, 5, 6
	)
	4）iota每遇到一次 const 关键字，iota 就重置为 0 
	const (
		a = iota
		b
		c
	)